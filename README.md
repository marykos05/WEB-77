# Отчет по аудиту безопасности веб-приложения

# Введение
Безопасность веб-приложений критически важна для защиты данных пользователей и предотвращения атак. В данном отчете рассмотрены основные уязвимости, методы их устранения и реализованные механизмы защиты.

# 1. Защита от XSS (Cross-Site Scripting)
# Уязвимость:
XSS позволяет злоумышленнику внедрять вредоносные JavaScript-коды через пользовательский ввод, которые выполняются в браузере других пользователей.

# Методы защиты:

1. Экранирование вывода:
Использование `htmlspecialchars()` с параметрами:
```php
htmlspecialchars($data, ENT_QUOTES | ENT_HTML5, 'UTF-8', true)
```
где:
`ENT_QUOTES` - экранирует и двойные, и одинарные кавычки
`ENT_HTML5` - оптимизация для HTML5
`UTF-8` - корректная обработка юникода
`true` - двойное экранирование существующих сущностей

2. HTTP-заголовки:
```php
header("X-XSS-Protection: 1; mode=block");
header("X-Content-Type-Options: nosniff");
```

3. Валидация ввода:
Регулярные выражения для проверки допустимых символов
Фильтрация специальных символов
```php
function safeOutput($data) {
    return htmlspecialchars($data, ENT_QUOTES | ENT_HTML5, 'UTF-8', true);
}
echo safeOutput($_POST['user_input']);
```
# Вывод:
После внедрения защиты:
Все пользовательские данные перед выводом проходят экранирование
Браузер получает четкие инструкции по обработке контента
Даже при попытке ввода скриптов они отображаются как текст, а не выполняются
Защита работает на всех страницах приложения, где выводится пользовательский ввод

# 2. Защита от Information Disclosure
# Уязвимость:
Раскрытие внутренней информации (ошибки БД, пути к файлам).

# Метод защиты:
Кастомизированные сообщения об ошибках
Логирование ошибок вместо вывода пользователю
```php
try {
    $stmt = $db->query("SELECT * FROM non_existent_table");
} catch (PDOException $e) {
    error_log($e->getMessage());
    die("Произошла ошибка. Попробуйте позже.");
}
```
# Вывод:
Теперь при ошибках пользователь видит общее сообщение, а детали пишутся в лог.

# 3. Защита от SQL-инъекций

# 4. Защита от CSRF (Межсайтовая подделка запроса)
# Уязвимость:
Возможность выполнения действий от имени авторизованного пользователя без его ведома.

# Методы защиты:

1. CSRF-токены:
Уникальный токен для каждой сессии
Токен добавляется в скрытое поле форм
Проверка токена при обработке POST-запросов
```php
// Генерация токена
if (empty($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}
// Проверка токена
if (!hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'] ?? '')) {
    die('Неверный CSRF-токен');
}
```
2. SameSite cookies:
```php
session_set_cookie_params(['samesite' => 'Lax']);
```
# Вывод:
После внедрения защиты:
Каждая форма требует уникальный токен
Токен привязан к сессии пользователя
Запросы с других сайтов (без токена) отклоняются
Куки не отправляются в межсайтовых запросах

# 5,6. Защита от Include/Upload уязвимостей
# Уязвимость: Возможность включения произвольных файлов или загрузки вредоносных файлов.

# Методы защиты:
Запрет включения файлов из пользовательского ввода
Валидация загружаемых файлов
Хранение загруженных файлов вне корневой директории
```php
if (isset($_FILES['file'])) {
    $allowedTypes = ['image/jpeg', 'image/png'];
    $maxSize = 2 * 1024 * 1024; // 2MB
    
    if (!in_array($_FILES['file']['type'], $allowedTypes)) {
        die('Недопустимый тип файла');
    }
    
    if ($_FILES['file']['size'] > $maxSize) {
        die('Файл слишком большой');
    }
    
    $extension = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);
    $filename = uniqid().'.'.$extension;
    move_uploaded_file($_FILES['file']['tmp_name'], '/var/www/uploads/'.$filename);
}
```
